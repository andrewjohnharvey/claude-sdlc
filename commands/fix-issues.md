# Fix-issue
The `/fix-issue` command automates the diagnosis and resolution of a specific bug or issue in the codebase. It accepts a flexible identifier or description for the problem (e.g. an issue ID, a short bug description, a file path, or even a URL to an issue report) and then runs through a **debug → fix → test** cycle to identify the root cause and apply a precise fix, much like an experienced developer would.

**Behavior:**
1. **Issue Understanding:** Claude first interprets the issue context from the given argument. If an issue number or link is provided (and access is available), it may fetch the issue details (for example, using the GitHub CLI with a command like **!**`gh issue view 123`) to gather the description and any error logs. If a file path or function name is given, it treats that as a hint to focus the search in that area of the code. Otherwise, Claude uses the argument text as the issue description. It ensures it has a clear understanding of the problem before proceeding (it may ask for clarification if the description is too vague or ambiguous).
2. **Reproducing/Identifying Cause:** The command then attempts to reproduce the issue or pinpoint its cause in the codebase:
    - It scans the code for clues such as error messages or keywords related to the bug (for example, grepping the repository with **!**`grep -R "NullPointerException" .` to find where a particular error string is coming from).
    - It may run the test suite or a specific failing test case associated with the issue to see the failure firsthand (e.g. executing **!**`npm test` or **!**`pytest` on a targeted test). This helps confirm the issue and locate the breakage.
    - If a stack trace or reproduction steps are provided in the issue description, Claude follows them to narrow down the problematic code path. For instance, for an issue "login page crashes on empty input", it would inspect the login handler logic for missing null-checks.
3. **Root Cause Analysis:** Once the relevant area is identified, Claude analyzes the code to determine the underlying cause of the bug. It will explain in its output what it believes is causing the issue (e.g. _"A null pointer exception occurs if the email field is empty, because the code assumes the value is non-empty when trimming the string"_). If the root cause isn’t immediately clear or if multiple causes are possible, Claude may highlight the uncertainty or ask the developer for additional information rather than proceeding on guesses. This ensures the fix addresses the real problem.
4. **Devise a Fix:** Next, Claude proceeds to implement a fix for the issue. It performs targeted code edits to resolve the bug, focusing only on the necessary files and code blocks (for example, adding a null check, correcting a conditional, or adjusting a function’s logic). If appropriate, it also **adds or updates unit tests** to cover this scenario and prevent regression. After applying code changes, Claude compiles and runs the relevant tests to verify that the issue is resolved – effectively doing a mini test run on the spot. For example, it might re-run the previously failing test with **!**`pytest -k "login_empty_input"` or run the project’s test suite to ensure no other tests break. If the fix doesn’t pass the tests, Claude will iterate (revising the fix or adjusting tests) until the bug appears resolved. All changes are made in-memory on the project files just as a developer editing the code.
5. **Confirmation & Documentation:** After applying the fix, Claude confirms that the issue is resolved (e.g. the test that used to fail now passes). It does _not_ automatically close external issue tickets, but it will mark the issue as fixed in its output and proceed to documentation. Specifically, the command generates a **mini fix report** in the project at `.claude-sdlc/fixes/<issue-id-or-slug>-<timestamp>.md`. This report contains a summary of the issue and the changes made to fix it, including which files/functions were modified and the outcome of the verification steps (for example, _"Fixed null check in `auth.py` and updated `test_auth.py` – all tests passing"_). If an issue tracker integration is available in the future, this step could also include posting a comment to the tracker or linking the report, but by default such actions are left to the developer.
6. **User Output:** Finally, `/fix-issue` presents the results to the developer. Claude will output a concise summary of the code changes (often including a diff snippet or code excerpt showing the fix) and a note that the issue has been resolved and tests are passing. For example, it might say: _“✅ Added a check for empty email input in `LoginService` and updated the UI to handle the error – all related tests now pass.”_ This gives the developer immediate feedback on what was changed. At this stage, Claude may also suggest next steps, such as running a `/code-review` on the changes for a quality check or doing additional manual testing. The goal is to ensure the developer is confident in the fix before it gets integrated

**Notes:**
- **No Auto-Commit by Default:** By design, `/fix-issue` leaves any code changes unstaged in your working directory (it does _not_ automatically commit them). This allows you to inspect the changes and run any additional tests or reviews. For safety, the command operates on your local repository copy (it may even use a separate fix branch or worktree internally to avoid messing up your main branch) so that if something goes wrong, your main branch remains unaffected. You can review all modifications in a diff and decide when to merge them.
- **Review and Follow-Up:** After using `/fix-issue`, it’s good practice to double-check the fix. The AI strives to follow project conventions and produce correct solutions, but peer review is still important. You might run `/code-review` on the codebase after the fix to get a thorough analysis of the changes, or simply examine the commit diff manually. This extra oversight helps ensure the issue is truly resolved and that the fix aligns with the codebase’s style and requirements. The `/fix-issue` command is meant to **accelerate** the bug-fixing process while keeping you in control – it handles the heavy lifting of debugging and patching, but leaves final judgment to the developer.