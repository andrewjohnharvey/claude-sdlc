# Security Audit

Performs a systematic, in-depth security audit across the entire project, scanning all source code, configuration, dependency, and infrastructure files for vulnerabilities and insecure practices. This command identifies issues such as hardcoded secrets, missing validation, misconfigurations, and outdated dependencies, and produces a detailed report of findings with severity ratings and recommended fixes.

## Instructions

1. **Initialize Audit Context**
    - Since the `/security-audit` command takes no arguments, it will audit the entire repository by default. Use shell commands (e.g., **!**`find . -type f`) to list all files in the project. Focus the scope on files likely to contain security-relevant content:
        - Source code files (e.g., `.js`, `.ts`, `.py`, `.java`, `.go`, `.rb`, etc.).
        - Configuration and environment files (e.g., `.env` files, `.yaml/.yml` configs, `.json` settings, `.ini/.properties` files).
        - Dependency manifests (e.g., `package.json`, `requirements.txt`, `Gemfile`, `pom.xml`, `go.mod`).
        - Infrastructure-as-code and containerization files, if present (e.g., `Dockerfile`, `docker-compose.yml`, Kubernetes YAML manifests, Terraform `.tf` scripts).
    - Exclude non-relevant files (such as documentation, images, build artifacts) so the audit focuses only on code and configuration. If certain expected file types are not present (for example, no Dockerfile or no Terraform scripts), handle this gracefully by skipping those checks without error.
    - Check for any project-specific security guidelines in the repository. For instance, if a `.claude-sdlc/architecture/` directory exists, look for security policy documents or threat models inside it. If found, read these to understand any additional rules or standards (e.g., required encryption algorithms, authentication requirements) that the project adheres to, and factor them into the audit criteria.
2. **Perform Security Analysis**
    - **Insecure Coding Practices:** Examine the source code for common insecure patterns. Look for hardcoded credentials or secrets (API keys, passwords embedded in code), lack of input validation or output encoding (which could allow SQL injection, XSS, or command injection attacks), use of obsolete or weak cryptographic functions, and dangerous functions like `eval()` or shell execution of user input. Also be mindful of regular expressions that could be vulnerable to denial-of-service (ReDoS) attacks. Flag any occurrences of these issues in the code.
    - **Authentication & Authorization Flaws:** Identify any weaknesses in how the application handles user authentication and access control. For example, check for routes or functions that do not enforce authentication when they should, improper or missing authorization checks (e.g., an admin-only action that isn’t actually restricted), use of default credentials or keys, and insecure password handling (such as unsalted hashes or weak hashing algorithms). Ensure that user roles/permissions are properly validated wherever applicable, and flag any logic that might allow privilege escalation or bypassing of security checks.
    - **Security Misconfigurations:** Review configuration files and runtime settings for insecure configurations. For instance, look for debug or verbose error modes enabled in production, overly permissive CORS settings (`Access-Control-Allow-Origin: *` without justification), missing important security headers (like Content Security Policy, X-Frame-Options, etc.), or unrestricted file upload settings. Also verify that no sensitive information (database passwords, API secrets, private keys) is unintentionally exposed in config files or logs. Any configuration that could weaken security should be noted.
    - **Vulnerable Dependencies:** Inspect the project’s dependencies for known security issues. Parse files like `package.json`, `requirements.txt`, `yarn.lock`, or others to get the list of dependency names and versions. Flag any libraries or packages that are outdated or have known vulnerabilities (for example, a dependency version with a published CVE or security advisory). Use Claude’s built-in knowledge or offline resources to identify major vulnerabilities by version. Recommend upgrading or patching dependencies that pose risks.
    - **Information Leakage:** Scan the code and configs for potential information leaks. This includes overly detailed error messages or stack traces that are logged or shown to users, any credentials or personal data being logged, or debug endpoints that return system info. For example, an error page that displays a full stack trace, or a commit of a file containing private keys, should be highlighted. Such findings indicate the application might inadvertently disclose sensitive information to an attacker or in logs.
    - **Infrastructure & Deployment Security:** If infrastructure-as-code files or container configurations exist, analyze them for weaknesses. For Dockerfiles, check that the image is using a minimal base and not running processes as root user (unless necessary), and that only needed ports are exposed. In Kubernetes YAML or Terraform scripts, look for overly open network rules (wide-open security groups or ingress rules), lack of TLS/SSL enforcement for services, or secrets stored in plaintext. Also ensure that environment variables or config in these files don’t contain secrets in plain text. Flag any insecure settings in deployment scripts or container configs.
    - As you examine each file, **flag any potential security issue** you discover. For each finding, record the relevant file path (and line number, if applicable), a brief description of the issue and why it’s a problem, and classify its severity as **Low**, **Medium**, **High**, or **Critical**. Wherever possible, include a specific recommendation for remediation. For example, if a secret key is hardcoded, the recommendation might be to move it to an environment variable or secret manager. These details will be compiled into the audit report.
3. **Report Results**
    - Compile the identified security issues into a Markdown report. Create a new file under `.claude-sdlc/builds/` to store the findings (for example, `.claude-sdlc/builds/2025-07-12T155000-security-audit.md` using the current timestamp in the filename). This ensures each audit is saved separately and chronologically.
    - Begin the report with a **high-level summary** of the audit results. Summarize how many issues were found and at what severities, and give an overall assessment of the project’s security posture. For example: _“Scanned 50 files – found 2 critical vulnerabilities, 5 high, 8 medium, and 10 low severity issues. Overall, the codebase follows several security best practices (e.g. use of parameterized queries in most places), but there are misconfigurations and outdated libraries that need attention.”_ Also mention any positive security aspects noted (such as use of a security framework, existence of unit tests for auth flows, etc.) to provide a balanced overview.
    - Include a **summary table** in the report that tallies the total number of findings by severity (e.g., Critical: 2, High: 5, Medium: 8, Low: 10). This gives the reader a quick view of the audit outcome.
    - Organize the detailed findings into sections by category or file for clarity. For example, you might separate issues into **Code Issues**, **Configuration Issues**, **Dependency Issues**, and **Infrastructure Issues** (or use the categories from the analysis step). Under each section, list each identified issue as an item with the relevant details:
        - Describe each issue briefly but clearly, and reference the file name and line number(s) if available so the developer knows where to look. For example: _`src/server.js:120` – **Critical:** Unvalidated user input is concatenated into an SQL query, creating an SQL injection risk; use parameterized queries or prepared statements to prevent this._
        - Provide a recommended remediation or best practice for each issue. Keep the tone factual and helpful. For instance, _“**High:** Hardcoded database password in `config/settings.py`. **Remediation:** Move sensitive credentials to environment variables or a secrets management service instead of hardcoding.”_
    - Ensure the report is well-structured and easy to navigate. Use clear **headings** for each category and bullet points or numbered lists for individual issues. If multiple issues are similar, you can group them or indicate their recurrence in different files to avoid repetition. The goal is to make it straightforward for the developer to understand each finding and how to address it.
    - **Do not modify any source code or configuration as part of this audit.** The report should strictly identify issues and suggest fixes, not perform them. After writing all findings and the summary into the Markdown file, save the file to disk (creating the `builds/` directory first if it doesn’t exist).
4. **Developer Guidance**
    - After saving the report, provide a concise summary of the audit results in the chat to guide the developer. For example, the assistant might say: _“✅ Security audit complete. Found 2 critical, 5 high, 8 medium, 10 low issues (see `.claude-sdlc/builds/2025-07-12T155000-security-audit.md` for details).”_ You might add a second sentence highlighting the most important finding or two, e.g. _“Critical issues involve hardcoded credentials and an open admin endpoint without authentication.”_ This gives the developer an immediate sense of urgency and focus.
    - Be sure to include the path to the saved report (the Markdown file) in the summary message, so the developer can easily open it for full details. Make it clear that the full report contains all findings categorized with detailed explanations and remediation steps.
    - Suggest **next steps** based on the audit findings to help the developer proceed in strengthening the project’s security. For instance:
        - If any **Critical** or **High** severity issues were found, recommend addressing those immediately. You can suggest using a command like `/fix-issue <file>:<line>` if an automated fix command exists in Claude-SDLC (for example, to quickly remove a hardcoded secret or patch a vulnerable dependency), or advise the developer to manually fix those issues as a top priority.
        - If numerous dependency vulnerabilities were noted, suggest reviewing and updating those libraries to safer versions. The developer might also run their package manager’s audit (e.g., `npm audit` or `pip audit`) outside of Claude for additional guidance, but the primary recommendation is to upgrade or replace vulnerable packages identified in the report.
        - If configuration weaknesses were identified (such as missing security headers or an overly permissive setting), advise the developer to update the configuration following best practices (e.g., add the appropriate headers, tighten the CORS policy, disable debug mode in production). Where relevant, point them to well-known hardening guidelines (for example, OWASP Secure Headers guidelines if headers are missing).
        - If authentication/authorization gaps were found, suggest implementing the necessary checks or protections (for example, adding role-based access control, introducing multi-factor authentication for admin users, or improving password storage mechanisms). Encourage adding unit or integration tests for these critical security flows if such tests are missing.
        - Encourage the developer to run `/security-audit` again after fixing the issues, or as part of their regular development cycle, to ensure that no new vulnerabilities are introduced and that the fixes adequately address the problems. This continuous re-auditing approach helps maintain a high security standard over time.
    - Throughout the guidance, keep a constructive and action-oriented tone. The aim is to empower the developer to improve the project’s security step by step. By clearly pointing out issues, providing actionable remediation advice, and suggesting follow-ups (like re-running audits or using fix commands), the `/security-audit` command integrates security best practices into the development workflow and helps prevent future vulnerabilities.