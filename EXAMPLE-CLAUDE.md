# CLAUDE.md - AI Development Guide

This file provides comprehensive guidance to Claude Code (claude.ai/code) when working with the Impact Studio codebase. It consolidates all patterns, guidelines, and references into a single source of truth.

## Table of Contents
1. [Quick Start](#quick-start)
2. [Architecture Overview](#architecture-overview)
3. [Development Guidelines](#development-guidelines)
4. [Copy-Paste Patterns](#copy-paste-patterns)
5. [Commands Reference](#commands-reference)
6. [Testing Strategy](#testing-strategy)
7. [Common Pitfalls](#common-pitfalls)
8. [Migration Status](#migration-status)

## Quick Start

### Essential Commands
```bash
npm run dev              # Start development
npm run dev:turbo        # Start with Turbopack (faster)
npx convex dev          # Start Convex (separate terminal)
npm run build           # Build for production
npm run lint            # Run ESLint
npm test                # Run tests
```

### Error Handling Decision Tree
```
Writing new code? → USE RESULT PATTERN (no exceptions)
Fixing a bug? → Keep existing try-catch pattern
Major refactor? → Convert to Result pattern
React ErrorBoundary? → Must use try-catch (React requirement)
```

### Result Pattern Quick Reference (NEW CODE ONLY)
```typescript
import { tryCatch, toastResult } from '@/lib/results';
import { retryOperationWithOnlineCheckResult } from '@/lib/retryUtils';

// Basic usage
const result = await tryCatch(async () => {
  return await mutation(api.items.create, data);
});

toastResult(result, "Success!");

// With retry for network operations
const result = await tryCatch(async () => {
  return await retryOperationWithOnlineCheckResult(
    () => mutation(api.items.create, data),
    { maxRetries: 3, showToastOnRetry: true }
  );
});

// Handle specific error types
result.match(
  (value) => { /* success */ },
  (error) => {
    switch (error.type) {
      case 'AUTH': router.push('/login'); break;
      case 'VALIDATION': setFieldError(error.field, error.message); break;
      case 'NOT_FOUND': router.push('/404'); break;
      default: toast.error(error.message);
    }
  }
);
```

## Architecture Overview

### Tech Stack
- **Frontend**: Next.js 15 (App Router), React 19, TypeScript
- **Backend**: Convex (real-time serverless database)
- **Styling**: Tailwind CSS v4, shadcn/ui components
- **Forms**: Custom form hooks with zod validation
- **Input Masking**: react-imask for currency/percentage inputs
- **UI Libraries**: Radix UI primitives, Lucide React icons
- **Notifications**: sonner for toast notifications
- **Theming**: next-themes for dark/light mode
- **Testing**: Vitest, React Testing Library

### Project Structure
```
src/
├── app/                    # Next.js app router pages
├── components/
│   ├── ui/                # shadcn/ui components + custom inputs
│   └── client-sections/   # Feature-specific sections
├── hooks/                 # Custom React hooks
├── lib/                   # Utilities (results.ts, retryUtils.ts, etc.)
├── services/              # Business logic services
└── types/                 # TypeScript type definitions

convex/
├── _generated/           # Auto-generated Convex types
├── schema.ts            # Database schema
├── clients.ts           # Client CRUD operations
├── healthPlans.ts       # Health plan operations
└── inputSanitization.ts # Security utilities
```

### Key Architectural Patterns

1. **Real-time Data Flow**
   - All data operations go through Convex functions
   - Use `useQuery` for reading data, `useMutation` for writes
   - Convex handles real-time synchronization automatically

2. **Type Safety**
   - Database schema defined in `convex/schema.ts`
   - Types auto-generated by Convex in `convex/_generated/`
   - Shared types in `src/types/`

3. **Component Organization**
   - UI components in `src/components/ui/` are from shadcn/ui
   - Feature components follow single responsibility
   - Complex features use folder structure (see MedicalPlanSection)

## Development Guidelines

### Core Principles

#### 1. Keep It Simple Stupid (KISS)
- Prefer simple, straightforward solutions
- Avoid premature optimization
- Use existing patterns and components
- Don't add complexity unless necessary

#### 2. Error Handling (CRITICAL)
- **NEW CODE**: MUST use Result pattern - NO EXCEPTIONS
- **EXISTING CODE**: Keep try-catch to minimize risk
- **React ErrorBoundaries**: Must use try-catch (React API constraint)

#### 3. Type Safety
- Use TypeScript strictly (no `any` types)
- Leverage IDE autocomplete
- Pay attention to TypeScript errors

#### 4. Testing
- Test all edge cases before marking complete
- Run `npm run build` before committing
- Test error scenarios (network failures, invalid inputs)

### Before Committing Checklist
- [ ] `npm run build` succeeds
- [ ] `npm run lint` passes
- [ ] `npm test` passes
- [ ] No console errors
- [ ] NEW CODE uses Result pattern
- [ ] Error cases handled
- [ ] Inputs sanitized
- [ ] Existing features still work

## Copy-Paste Patterns

### Error Handling Pattern

#### Primary Pattern (Result) - ALL NEW CODE
```typescript
import { tryCatch, toastResult } from '@/lib/results';
import { retryOperationWithOnlineCheckResult } from '@/lib/retryUtils';

// Basic usage
const result = await tryCatch(async () => {
  return await mutation(api.something.create, data);
});

toastResult(result, "Operation successful");

// With retry logic for network issues
const result = await tryCatch(async () => {
  return await retryOperationWithOnlineCheckResult(
    () => mutation(api.something.create, data),
    { maxRetries: 3, showToastOnRetry: true }
  );
});

toastResult(result, "Operation successful");

// Handling results explicitly
result.match(
  (value) => {
    // Handle success
    console.log('Success:', value);
    router.push('/success');
  },
  (error) => {
    // Handle different error types
    switch (error.type) {
      case 'AUTH':
        router.push('/login');
        break;
      case 'VALIDATION':
        setFieldError(error.field, error.message);
        break;
      case 'NOT_FOUND':
        router.push('/404');
        break;
      default:
        toast.error(error.message);
    }
  }
);
```

#### Legacy Pattern (Try-Catch) - EXISTING CODE ONLY
```typescript
// Only use for existing code or React ErrorBoundaries
try {
  await mutation(api.something.create, data);
  toast.success("Success!");
} catch (error) {
  const errorMessage = error instanceof Error ? error.message : "Something went wrong";
  toast.error(errorMessage);
  console.error("Error details:", error);
}
```

### Form Pattern with Result

```typescript
"use client";

import React, { useState } from "react";
import { useMutation } from "convex/react";
import { tryCatch, toastResult } from '@/lib/results';
import { Button } from "@/components/ui/button";
import { ValidatedInput } from "@/components/ui/validated-input";
import { CurrencyInput } from "@/components/ui/currency-input";
import { PercentageInput } from "@/components/ui/percentage-input";
import { api } from "../convex/_generated/api";

export function MyForm() {
  const [formData, setFormData] = useState({
    name: "",
    amount: 0,
    percentage: 0,
  });
  
  const [errors, setErrors] = useState<Record<string, string>>({});
  const [isSubmitting, setIsSubmitting] = useState(false);
  
  const createItem = useMutation(api.items.create);
  
  // Form submission with Result pattern (NEW CODE)
  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validate()) {
      toast.error("Please fix the validation errors");
      return;
    }
    
    setIsSubmitting(true);
    
    const result = await tryCatch(async () => {
      return await createItem(formData);
    });
    
    setIsSubmitting(false);
    
    toastResult(result, "Item created successfully");
    
    if (result.isOk()) {
      // Reset form on success
      setFormData({ name: "", amount: 0, percentage: 0 });
      setErrors({});
      router.push('/success');
    }
  };
  
  return (
    <form onSubmit={handleSubmit} className="space-y-4">
      <ValidatedInput
        label="Name"
        value={formData.name}
        onChange={(e) => setFormData(prev => ({ ...prev, name: e.target.value }))}
        error={errors.name}
        required
      />
      
      <CurrencyInput
        label="Amount"
        value={formData.amount}
        onChange={(value) => setFormData(prev => ({ ...prev, amount: value }))}
        error={errors.amount}
        min={0}
      />
      
      <PercentageInput
        label="Percentage"
        value={formData.percentage}
        onChange={(value) => setFormData(prev => ({ ...prev, percentage: value }))}
        error={errors.percentage}
        min={0}
        max={100}
      />
      
      <Button type="submit" disabled={isSubmitting}>
        {isSubmitting ? "Creating..." : "Create Item"}
      </Button>
    </form>
  );
}
```

### Component Structure Pattern

For complex features, follow this folder structure:

```
src/components/feature-name/
├── index.tsx                    # Main component export
├── FeatureName.tsx             # Main component implementation
├── FeatureDialog.tsx           # Modal/dialog component
├── FeatureList.tsx            # List display component
├── FeatureEmptyState.tsx      # Empty state component
├── components/                 # Sub-components
│   └── FeatureCard.tsx
├── hooks/                      # Feature-specific hooks
│   ├── index.tsx
│   ├── useFeatureData.ts
│   └── useFeatureForm.ts
├── constants/                  # Feature constants
│   └── featureConstants.ts
├── schemas/                    # Validation schemas
│   └── featureSchemas.ts
└── types/                      # Feature-specific types
    └── featureTypes.ts
```

### Convex CRUD Pattern with Result

#### NEW PATTERN: Using Result types (for new code)
```typescript
import { convexMutation } from '@/lib/convex-results';
import { ok, err } from 'neverthrow';
import { validationError, notFoundError, unknownError } from '@/lib/results';
import { sanitizeString, sanitizeNumber } from '../inputSanitization';

export const createItemWithResult = convexMutation<Args, Id<"items">>(
  async (ctx, args) => {
    await requireAuth(ctx);
    
    // Validation with Result
    if (!args.name) {
      return err(validationError("Name is required", "name"));
    }
    
    if (args.amount < 0) {
      return err(validationError("Amount must be non-negative", "amount"));
    }
    
    // Check if client exists
    const client = await ctx.db.get(args.clientId);
    if (!client) {
      return err(notFoundError("Client not found"));
    }
    
    try {
      // Create with sanitized data
      const itemId = await ctx.db.insert("items", {
        clientId: args.clientId,
        name: sanitizeString(args.name, { maxLength: 100 }),
        amount: sanitizeNumber(args.amount, { min: 0, max: 1000000 }),
        // ... other fields
      });
      
      // Audit log (non-critical)
      try {
        await ctx.db.insert("auditLogs", {
          entityType: "item",
          entityId: itemId,
          action: "create",
          timestamp: Date.now(),
          changes: args,
          metadata: { clientId: args.clientId },
        });
      } catch (auditError) {
        console.error("Failed to log audit:", auditError);
      }
      
      return ok(itemId);
    } catch (error) {
      return err(unknownError(
        `Failed to create item: ${error instanceof Error ? error.message : String(error)}`,
        error
      ));
    }
  }
);
```

#### LEGACY PATTERN: Traditional mutation (existing code)
```typescript
export const createItem = mutation({
  args: {
    clientId: v.id("clients"),
    name: v.string(),
    amount: v.number(),
  },
  handler: async (ctx, args) => {
    await requireAuth(ctx);
    
    try {
      // Validation
      if (!args.name) {
        throw new Error("Name is required");
      }
      
      // Create the item
      const itemId = await ctx.db.insert("items", {
        clientId: args.clientId,
        name: sanitizeString(args.name),
        amount: sanitizeNumber(args.amount),
      });
      
      return itemId;
    } catch (error) {
      console.error("Error creating item:", error);
      throw new Error(`Failed to create item: ${error instanceof Error ? error.message : String(error)}`);
    }
  },
});
```

### Security Pattern

Always sanitize user inputs:

```typescript
import { 
  sanitizeString, 
  sanitizeNumber, 
  sanitizeEmail,
  sanitizeUrl,
  sanitizePlanId
} from "../convex/inputSanitization";

// With Result pattern (NEW CODE)
const nameResult = sanitizeString(args.name, { maxLength: 100 });
if (!nameResult) {
  return err(validationError("Invalid name format", "name"));
}

// Direct usage (EXISTING CODE)
const sanitizedData = {
  name: sanitizeString(args.name, { maxLength: 100 }),
  email: sanitizeEmail(args.email),
  amount: sanitizeNumber(args.amount, { min: 0, max: 1000000 }),
  planId: sanitizePlanId(args.planId),
};
```

### Loading States
```typescript
{isLoading ? (
  <div className="flex items-center justify-center py-8">
    <Loader2 className="h-8 w-8 animate-spin" />
  </div>
) : (
  <YourContent />
)}
```

### Empty States
```typescript
{items.length === 0 ? (
  <Card>
    <CardContent className="py-8">
      <div className="text-center text-muted-foreground">
        <Icon className="h-12 w-12 mx-auto mb-4 opacity-50" />
        <p className="text-sm mb-2">No items found</p>
        <p className="text-xs">Click "Add Item" to create your first item</p>
      </div>
    </CardContent>
  </Card>
) : (
  <ItemsList items={items} />
)}
```

### Dialog Pattern
```typescript
<Dialog open={isOpen} onOpenChange={setIsOpen}>
  <DialogContent>
    <DialogHeader>
      <DialogTitle>Dialog Title</DialogTitle>
      <DialogDescription>
        Dialog description
      </DialogDescription>
    </DialogHeader>
    {/* Content */}
    <DialogFooter>
      <Button variant="outline" onClick={() => setIsOpen(false)}>
        Cancel
      </Button>
      <Button onClick={handleSubmit}>
        Confirm
      </Button>
    </DialogFooter>
  </DialogContent>
</Dialog>
```

## Commands Reference

### Development
```bash
# Start development server on port 3001
npm run dev

# Start with Turbopack (faster builds)
npm run dev:turbo

# Start Convex backend (run in separate terminal)
npx convex dev
```

### Building and Production
```bash
# Build for production (runs convex codegen first)
npm run build

# Start production server
npm start
```

### Code Quality
```bash
# Run ESLint
npm run lint

# Run tests with Vitest
npm test

# Run tests in watch mode
npm run test:watch

# Generate test coverage report
npm run test:coverage

# Open Vitest UI
npm run test:ui

# Type checking
npx tsc --noEmit
```

### Database
```bash
# Execute Convex functions
npx convex run

# Open Convex dashboard
npx convex dashboard
```

## Testing Strategy

### Testing Requirements
Before marking any task complete:
1. Run `npm run build` - must succeed
2. Run `npm run lint` - fix any errors
3. Run `npm test` - ensure tests pass
4. Test manually in browser - check console for errors
5. Test error scenarios - invalid inputs, network failures
6. Verify existing functionality still works
7. NEW CODE uses Result pattern (not try-catch)

### Manual Testing Steps
1. **Homepage functionality**
   - Search for clients works
   - Pin/unpin functionality works
   - Share functionality works
   - Error messages display properly

2. **Client detail pages**
   - Individual client pages load
   - All client information displays correctly
   - Navigation works properly

3. **Error scenarios**
   - Invalid client IDs show appropriate errors
   - Network failures are handled gracefully
   - User actions provide feedback

### Before Deployment
1. Run `npm run build` to ensure production build works
2. Test critical user flows manually
3. Check browser console for errors
4. Verify Convex functions work as expected

### Component Testing Pattern
```typescript
import { describe, it, expect, vi } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { MyComponent } from './MyComponent';

describe('MyComponent', () => {
  it('should handle user interactions', async () => {
    const onSubmit = vi.fn();
    render(<MyComponent onSubmit={onSubmit} />);
    
    // Test user interaction
    const button = screen.getByRole('button', { name: /submit/i });
    fireEvent.click(button);
    
    expect(onSubmit).toHaveBeenCalled();
  });
});
```

### Convex Testing Pattern
```typescript
import { convexTest } from "convex-test";
import { expect, test, describe } from "vitest";
import schema from "./schema";
import { api } from "./_generated/api";

describe("Item CRUD Operations", () => {
  test("should create item with validation", async () => {
    const t = convexTest(schema);
    
    // Test creation
    const itemId = await t.mutation(api.items.create, {
      name: "Test Item",
      amount: 100
    });
    
    expect(itemId).toBeDefined();
    
    // Test validation
    await expect(t.mutation(api.items.create, {
      name: "", // Invalid
      amount: -100 // Invalid
    })).rejects.toThrow();
  });
});
```

## Common Pitfalls

### 1. Next.js Server/Client Component Issues
- **Problem**: Passing event handlers from server to client components
- **Solution**: Ensure client components are marked with `"use client"`
- **Example**: Error boundaries with `onError` props

### 2. Convex Query/Mutation Errors
- **Problem**: Not handling undefined query results
- **Solution**: Always check if data exists before using it
- **Example**: `if (data === undefined) return <Loading />`

### 3. TypeScript Import Errors
- **Problem**: Importing non-existent modules or components
- **Solution**: Use IDE autocomplete and check file paths

### 4. Async Operation Errors
- **Problem**: Unhandled promise rejections
- **Solution for NEW CODE**: Always use Result types with `tryCatch`
- **Solution for EXISTING CODE**: Keep try-catch blocks
- **Migration**: Convert to Result pattern only during feature work or refactors

## Migration Status

### Error Handling Migration Progress
- **Current State**: ~90 try-catch blocks, ~66 Result pattern uses
- **Phase 1 (Active)**: All new code uses Result pattern
- **Phase 2 (Ongoing)**: Opportunistic migration during feature work
- **Phase 3 (Future)**: Dedicated migration sprints

### High-Priority Migration Targets
1. Network operations in `useHealthPlanCRUD.ts`
2. Form submissions in `MedicalPlanSection`
3. Client data operations in `clients.ts`
4. Health plan CRUD in `healthPlans.ts`

### Files to Keep Try-Catch
- React ErrorBoundaries (React API requirement)
- Third-party library integrations
- Simple synchronous operations
- Test utilities

## Additional Resources

### Specialized Component Patterns

1. **Input Components**
   - `ValidatedInput` - Input with built-in validation and error display
   - `ValidatedSelect` - Select with validation
   - `CurrencyInput` - Masked currency input using react-imask
   - `PercentageInput` - Masked percentage input using react-imask
   - `HydrationSafeInput` - Input that handles SSR/hydration safely

2. **Form Patterns**
   - `FormField` - Wrapper for consistent form field layout
   - `FormSection` - Groups related form fields with headers
   - Section-specific components: `BasicInfoSection`, `PremiumSection`, etc.

3. **Error Handling Components**
   - `ErrorBoundary` - React error boundary wrapper
   - `ErrorFallback` - UI component for error states
   - `OfflineIndicator` - Shows when app is offline

### Custom Hooks

1. **Data Management Hooks**
```typescript
// Data caching with LRU eviction
import { useDataCache } from '@/hooks/useDataCache';

const cache = useDataCache<HealthPlan>({ 
  ttl: 300000, // 5 minutes
  maxSize: 50 
});

// Optimistic updates for better UX
import { useOptimisticUpdates } from '@/hooks/useOptimisticUpdates';

const {
  data,
  optimisticCreate,
  optimisticUpdate,
  optimisticDelete,
  confirmUpdate,
  revertUpdate
} = useOptimisticUpdates(initialData);

// Handle optimistic create
const handleCreate = async (newItem) => {
  const tempId = optimisticCreate(newItem);
  try {
    const result = await createMutation(newItem);
    confirmUpdate(tempId, result.id);
  } catch (error) {
    revertUpdate(tempId);
    throw error;
  }
};
```

2. **Form Enhancement Hooks**
```typescript
// Form validation with debouncing
import { useFormValidation } from '@/hooks/useFormValidation';
import { useDebouncedValidation } from '@/hooks/useDebouncedValidation';
import { useFormDirtyState } from '@/hooks/useFormDirtyState';

const { errors, validate } = useFormValidation(formData, validationSchema);
const debouncedValue = useDebouncedValidation(inputValue, 500);
const { isDirty, setDirty, resetDirty } = useFormDirtyState();
```

3. **UI Enhancement Hooks**
```typescript
// Dialog keyboard navigation
import { useDialogKeyboard } from '@/hooks/useDialogKeyboard';
import { useNetworkStatus } from '@/hooks/useNetworkStatus';

const dialogRef = useDialogKeyboard({
  isOpen,
  onClose: () => setIsOpen(false),
});

const { isOnline, wasOffline } = useNetworkStatus();
```

### Security Guidelines
- Always sanitize user inputs using provided functions
- Test for XSS vulnerabilities with payloads like `<script>alert('XSS')</script>`
- Use `logSecurityEvent()` to log suspicious activities
- Never use `dangerouslySetInnerHTML` without proper sanitization
- All numeric fields have strict min/max validation

### Convex-Specific Guidelines
- Use `v.id("tableName")` for ID validators
- Implement pagination with cursors for large datasets
- Use `searchIndex` for full-text search
- Store files using Convex file storage, not as base64
- For actions (external API calls), use `action` not `mutation`

### Performance Optimization
- **Caching**: Use `useDataCache()` for frequently accessed data
- **Optimistic Updates**: Use `useOptimisticUpdates()` for immediate UI feedback
- **Debounced Validation**: Use `useDebouncedValidation()` to reduce validation calls
- **Query Optimization**: Use specific queries instead of broad data fetching

### Database Change Procedures

#### Convex Schema Changes
1. **Plan the change**
   - Understand impact on existing data
   - Consider backward compatibility
   - Plan migration strategy if needed

2. **Implement carefully**
   - Update schema.ts first
   - Update affected functions
   - Test with existing data
   - Verify queries still work

3. **Deploy safely**
   - Test in development environment first
   - Monitor for errors after deployment
   - Have rollback plan ready

#### Adding New Fields
1. Make new fields optional initially
2. Update functions to handle both old and new data
3. Test thoroughly before making fields required

### Emergency Procedures

#### If the Application is Broken
1. **Immediate response**
   - Check the development server output for errors
   - Look at browser console for client-side errors
   - Identify the last change that might have caused the issue

2. **Quick fixes**
   - Revert the most recent changes if possible
   - Comment out problematic code temporarily
   - Use git to restore working state

3. **Proper resolution**
   - Fix the root cause of the issue
   - Test the fix thoroughly
   - Document what went wrong and how it was fixed

### Debugging Tips
- Use browser DevTools Network tab for API issues
- Check Convex dashboard for function errors
- Use console.log for debugging (remove before committing)
- Test in incognito mode to avoid cache issues

## Memories and Notes

### Critical Reminders
- **ALL NEW CODE MUST USE RESULT PATTERN** - No exceptions
- Security is paramount - always sanitize inputs
- Follow KISS principle - keep solutions simple
- Test thoroughly before marking complete

### Related Documentation
- **MIGRATION_TRACKING.md**: Tracks Result pattern adoption progress
- **docs/neverthrow-*.md**: Detailed NeverThrow guides
- **Andrew's CLAUDE.md**: Personal development preferences

### When Working on This Project
1. Check this file first for patterns and guidelines
2. Use Result pattern for all new code
3. Keep try-catch only for existing code fixes
4. Run all tests before committing
5. Sanitize all user inputs

Remember: Simplicity and consistency are key. When in doubt, follow existing patterns.